'use client'

import { useEffect, useState, useMemo, useCallback } from 'react'
import { createClient } from '@/lib/supabase/client'
import { useRouter } from 'next/navigation'
import { Database } from '@/lib/supabase/database.types'
import { ArrowLeft, Plus, Minus, Send, Trash2 } from 'lucide-react'

type Product = Database['public']['Tables']['products']['Row']
type Order = Database['public']['Tables']['orders']['Row'] & {
  order_items: (Database['public']['Tables']['order_items']['Row'] & {
    products: Product
  })[]
  users?: Database['public']['Tables']['users']['Row']
}
type Table = Database['public']['Tables']['tables']['Row']

interface OrderPageProps {
  tableId: string
}

export default function OrderPage({ tableId }: OrderPageProps) {
  const router = useRouter()
  const supabase = useMemo(() => {
    if (typeof window !== 'undefined') {
      return createClient()
    }
    return null
  }, [])
  const [table, setTable] = useState<Table | null>(null)
  const [products, setProducts] = useState<Product[]>([])
  const [order, setOrder] = useState<Order | null>(null)
  const [loading, setLoading] = useState(true)
  const [selectedProducts, setSelectedProducts] = useState<Record<string, number>>({})
  const [productNotes, setProductNotes] = useState<Record<string, string>>({})
  const [showMenu, setShowMenu] = useState(false)

  useEffect(() => {
    if (!supabase) return
    
    loadData()

    // Subscribe to order changes
    const channel = supabase
      .channel(`order-${tableId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'orders',
          filter: `table_id=eq.${tableId}`,
        },
        () => {
          loadOrder()
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'order_items',
        },
        () => {
          loadOrder()
        }
      )
      .subscribe()

    return () => {
      if (supabase) {
        supabase.removeChannel(channel)
      }
    }
  }, [tableId, supabase])

  const loadOrder = useCallback(async () => {
    if (!supabase) return
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return

    // Get active order for this table (only one order per table)
    const { data: orderData } = await supabase
      .from('orders')
      .select(
        `
        *,
        order_items (
          *,
          products (*)
        )
      `
      )
      .eq('table_id', tableId)
      .in('status', ['open', 'sent'])
      .single()

    if (orderData) {
      setOrder(orderData as Order)
    } else {
      setOrder(null)
    }
  }, [supabase, tableId])

  const loadData = async () => {
    await Promise.all([loadTable(), loadProducts(), loadOrder()])
    setLoading(false)
  }

  const loadTable = async () => {
    if (!supabase) return
    const { data } = await supabase
      .from('tables')
      .select('*')
      .eq('id', tableId)
      .single()

    if (data) setTable(data)
  }

  const loadProducts = async () => {
    if (!supabase) return
    // Get user's restaurant_id
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return

    const { data: userProfile } = await supabase
      .from('users')
      .select('restaurant_id')
      .eq('id', user.id)
      .single()

    if (!userProfile?.restaurant_id) return

    const { data } = await supabase
      .from('products')
      .select('*')
      .eq('restaurant_id', userProfile.restaurant_id)
      .eq('is_active', true)
      .order('name')

    if (data) setProducts(data)
  }

  const getCurrentOrder = useCallback(async () => {
    if (!supabase) return null
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return null

    const { data } = await supabase
      .from('orders')
      .select(
        `
        *,
        order_items (
          *,
          products (*)
        )
      `
      )
      .eq('table_id', tableId)
      .in('status', ['open', 'sent'])
      .single()

    return data as Order | null
  }, [supabase, tableId])

  const createOrder = useCallback(async (): Promise<Order | null> => {
    if (!supabase) return null
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) return null

    // order_number will be auto-generated by trigger
    const { data: newOrder, error } = await supabase
      .from('orders')
      .insert({
        table_id: tableId,
        status: 'open',
        created_by_id: user.id,
      } as any)
      .select(`
        *,
        order_items (
          *,
          products (*)
        )
      `)
      .single()

    if (error) {
      console.error('Error creating order:', error)
      alert('Sipari≈ü olu≈üturulurken hata: ' + error.message)
      return null
    }

    // Ensure order_items is an array (new orders will have empty array)
    const orderWithItems: Order = {
      ...(newOrder as any),
      order_items: (newOrder as any).order_items || []
    }
    await loadOrder()
    return orderWithItems
  }, [supabase, tableId, loadOrder])

  const addProductToOrder = useCallback(async (productId: string, quantity: number, note?: string) => {
    if (!supabase) {
      console.error('Supabase client not available')
      return
    }

    try {
      // Get current order or create one
      let currentOrder = order
      if (!currentOrder) {
        const newOrder = await createOrder()
        if (newOrder) {
          // Use the newly created order directly
          currentOrder = newOrder
          // Also update state by loading order
          await loadOrder()
        } else {
          // If createOrder failed, try to get existing order as fallback
          currentOrder = await getCurrentOrder()
        }
      }

      if (!currentOrder) {
        alert('Sipari≈ü olu≈üturulamadƒ±. L√ºtfen tekrar deneyin.')
        return
      }

      // Check if order is paid
      if (currentOrder.status === 'paid') {
        alert('√ñdeme alƒ±nmƒ±≈ü sipari≈üe √ºr√ºn eklenemez')
        return
      }

      const product = products.find((p) => p.id === productId)
      if (!product) {
        alert('√úr√ºn bulunamadƒ±')
        return
      }

      const noteText = note?.trim() || null

      // Check if item already exists in order (same product, same note, not sent to kitchen)
      const existingItem = (currentOrder.order_items || []).find(
        (item) => item.product_id === productId && 
                  !item.is_sent_to_kitchen &&
                  ((!item.note && !noteText) || item.note === noteText)
      )

      if (existingItem) {
        // Update quantity
        const newQuantity = existingItem.quantity + quantity
        if (newQuantity <= 0) {
          // Remove item
          const { error } = await supabase.from('order_items').delete().eq('id', existingItem.id)
          if (error) throw error
        } else {
          const { error } = await supabase
            .from('order_items')
            .update({ quantity: newQuantity })
            .eq('id', existingItem.id)
          if (error) throw error
        }
      } else {
        // Add new item
        const { error } = await supabase.from('order_items').insert({
          order_id: currentOrder.id,
          product_id: productId,
          quantity: quantity,
          price: product.price,
          is_sent_to_kitchen: false,
          note: noteText,
        })
        if (error) throw error
      }

      await loadOrder()
      setSelectedProducts(prev => {
        const newState = { ...prev }
        delete newState[productId]
        return newState
      })
      setProductNotes(prev => {
        const newState = { ...prev }
        delete newState[productId]
        return newState
      })
    } catch (error: any) {
      console.error('Error adding product to order:', error)
      alert('√úr√ºn eklenirken hata olu≈ütu: ' + (error.message || 'Bilinmeyen hata'))
    }
  }, [supabase, order, products, tableId, loadOrder, getCurrentOrder, createOrder])

  const sendToKitchen = async () => {
    if (!supabase) return
    if (!order) return

    const unsentItems = order.order_items.filter((item) => !item.is_sent_to_kitchen)

    if (unsentItems.length === 0) {
      alert('Mutfaƒüa g√∂nderilecek √ºr√ºn yok')
      return
    }

    // Check stock availability before sending (client-side check for better UX)
    const stockErrors: string[] = []
    for (const item of unsentItems) {
      if (item.products.stock_enabled) {
        const { data: productData } = await supabase
          .from('products')
          .select('stock_quantity, name')
          .eq('id', item.product_id)
          .single()

        if (productData && productData.stock_quantity < item.quantity) {
          stockErrors.push(`${item.products.name}: Mevcut ${productData.stock_quantity}, ƒ∞stenen ${item.quantity}`)
        }
      }
    }

    if (stockErrors.length > 0) {
      alert('Yetersiz stok:\n' + stockErrors.join('\n'))
      return
    }

    // Mark items as sent to kitchen (trigger will handle stock decrease)
    const itemIds = unsentItems.map((item) => item.id)
    const { error: updateError } = await supabase
      .from('order_items')
      .update({
        is_sent_to_kitchen: true,
        sent_at: new Date().toISOString(),
      })
      .in('id', itemIds)

    if (updateError) {
      console.error('Error updating order items:', updateError)
      if (updateError.message.includes('Yetersiz stok')) {
        alert('Stok hatasƒ±: ' + updateError.message)
      } else {
        alert('Sipari≈ü g√∂nderilirken hata: ' + updateError.message)
      }
      return
    }

    // Update order status to 'sent'
    const { error: orderError } = await supabase
      .from('orders')
      .update({ status: 'sent' })
      .eq('id', order.id)

    if (orderError) {
      console.error('Error updating order status:', orderError)
      alert('Sipari≈ü durumu g√ºncellenirken hata: ' + orderError.message)
      return
    }

    alert('Sipari≈ü mutfaƒüa g√∂nderildi ve stoktan d√º≈ü√ºr√ºld√º!')
    await loadOrder()
  }

  const removeItem = async (itemId: string) => {
    if (!supabase) return
    if (!order) return

    const item = order.order_items.find((i) => i.id === itemId)
    if (!item) return

    // Allow deletion even if item is sent to kitchen, but warn user
    if (item.is_sent_to_kitchen) {
      const confirmed = confirm(
        'Bu √ºr√ºn mutfaƒüa g√∂nderilmi≈ü. Silmek istediƒüinizden emin misiniz?'
      )
      if (!confirmed) return
    }

    // Prevent deletion from paid orders
    if (order.status === 'paid') {
      alert('√ñdeme alƒ±nmƒ±≈ü sipari≈üten √ºr√ºn silinemez')
      return
    }

    const { error } = await supabase.from('order_items').delete().eq('id', itemId)
    
    if (error) {
      console.error('Error removing item:', error)
      alert('√úr√ºn silinirken hata: ' + error.message)
      return
    }

    await loadOrder()
  }

  const updateItemQuantity = async (itemId: string, newQuantity: number) => {
    if (!supabase) return
    if (!order) return

    const item = order.order_items.find((i) => i.id === itemId)
    if (!item) return

    if (item.is_sent_to_kitchen) {
      alert('Mutfaƒüa g√∂nderilmi≈ü √ºr√ºn√ºn miktarƒ± deƒüi≈ütirilemez')
      return
    }

    if (order.status === 'paid') {
      alert('√ñdeme alƒ±nmƒ±≈ü sipari≈üte √ºr√ºn miktarƒ± deƒüi≈ütirilemez')
      return
    }

    if (newQuantity <= 0) {
      await removeItem(itemId)
    } else {
      await supabase
        .from('order_items')
        .update({ quantity: newQuantity })
        .eq('id', itemId)
    }

    await loadOrder()
  }

  if (loading) {
    return <div className="text-center py-8">Y√ºkleniyor...</div>
  }

  const canEdit = order && order.status !== 'paid'
  const unsentItems = order?.order_items.filter((item) => !item.is_sent_to_kitchen) || []
  const sentItems = order?.order_items.filter((item) => item.is_sent_to_kitchen) || []

  return (
    <div className="space-y-4">
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <button
          onClick={() => router.push('/waiter')}
          className="flex items-center gap-2 text-gray-600 hover:text-gray-900 w-fit"
        >
          <ArrowLeft className="w-5 h-5" />
          <span>Masalar</span>
        </button>
        <h2 className="text-xl sm:text-2xl font-bold text-center sm:text-left">
          Masa {table?.table_number} - Sipari≈ü
        </h2>
      </div>

      {/* Menu Toggle */}
      <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-2">
        <button
          onClick={() => setShowMenu(!showMenu)}
          className="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
        >
          {showMenu ? 'Men√ºy√º Gizle' : 'Men√ºy√º G√∂ster'}
        </button>
        {order && canEdit && unsentItems.length > 0 && (
          <button
            onClick={sendToKitchen}
            className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
          >
            <Send className="w-4 h-4" />
            Mutfaƒüa G√∂nder ({unsentItems.length})
          </button>
        )}
      </div>

      {/* Product Menu */}
      {showMenu && (
        <div className="bg-white rounded-lg shadow p-4">
          <h3 className="text-lg font-semibold mb-4">Men√º</h3>
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
            {products.map((product) => (
              <div
                key={product.id}
                className="border rounded-lg p-3 hover:bg-gray-50 flex flex-col"
              >
                <div className="font-semibold mb-1">{product.name}</div>
                <div className="text-sm text-gray-600 mb-2">
                  {product.price.toFixed(2)} ‚Ç∫
                </div>
                <div className="flex items-center gap-2 mb-2">
                  <button
                    onClick={() => {
                      const current = selectedProducts[product.id] || 0
                      setSelectedProducts({
                        ...selectedProducts,
                        [product.id]: Math.max(0, current - 1),
                      })
                    }}
                    className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0"
                  >
                    <Minus className="w-4 h-4" />
                  </button>
                  <span className="w-8 text-center flex-shrink-0">
                    {selectedProducts[product.id] || 0}
                  </span>
                  <button
                    onClick={() => {
                      const current = selectedProducts[product.id] || 0
                      setSelectedProducts({
                        ...selectedProducts,
                        [product.id]: current + 1,
                      })
                    }}
                    className="p-1 bg-gray-200 rounded hover:bg-gray-300 flex-shrink-0"
                  >
                    <Plus className="w-4 h-4" />
                  </button>
                  {(selectedProducts[product.id] || 0) > 0 && (
                    <button
                      onClick={(e) => {
                        e.preventDefault()
                        e.stopPropagation()
                        addProductToOrder(product.id, selectedProducts[product.id] || 0, productNotes[product.id])
                      }}
                      className="ml-auto px-3 py-1 bg-indigo-600 text-white text-xs rounded hover:bg-indigo-700 flex-shrink-0"
                      type="button"
                    >
                      Ekle
                    </button>
                  )}
                </div>
                {(selectedProducts[product.id] || 0) > 0 && (
                  <input
                    type="text"
                    placeholder="Not (√∂rn: az ekmekli)"
                    value={productNotes[product.id] || ''}
                    onChange={(e) => {
                      setProductNotes({
                        ...productNotes,
                        [product.id]: e.target.value,
                      })
                    }}
                    className="w-full text-xs px-2 py-1.5 border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-indigo-500"
                    onClick={(e) => e.stopPropagation()}
                  />
                )}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Order Items */}
      {order && (
        <div className="bg-white rounded-lg shadow p-4">
          <div className="flex justify-between items-center mb-4">
            <h3 className="text-lg font-semibold">Sipari≈ü Detayƒ±</h3>
            <span
              className={`px-3 py-1 rounded text-sm font-medium ${
                order.status === 'open'
                  ? 'bg-yellow-100 text-yellow-800'
                  : order.status === 'sent'
                  ? 'bg-blue-100 text-blue-800'
                  : 'bg-green-100 text-green-800'
              }`}
            >
              {order.status === 'open'
                ? 'A√ßƒ±k'
                : order.status === 'sent'
                ? 'G√∂nderildi'
                : '√ñdendi'}
            </span>
          </div>

          {/* Unsent Items */}
          {unsentItems.length > 0 && (
            <div className="mb-4">
              <h4 className="font-medium text-gray-700 mb-2">Yeni √úr√ºnler</h4>
              <div className="space-y-2">
                {unsentItems.map((item) => (
                  <div
                    key={item.id}
                    className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 p-2 bg-yellow-50 rounded"
                  >
                    <div className="flex-1 w-full">
                      <div className="font-medium">{item.products.name}</div>
                      <div className="text-sm text-gray-600">
                        {item.price.toFixed(2)} ‚Ç∫ x {item.quantity} ={' '}
                        {(item.price * item.quantity).toFixed(2)} ‚Ç∫
                      </div>
                      {item.note && (
                        <div className="text-xs text-indigo-600 mt-1 italic">
                          üìù {item.note}
                        </div>
                      )}
                    </div>
                    {canEdit && (
                      <div className="flex items-center gap-1 sm:gap-2 flex-shrink-0">
                        <button
                          onClick={() => updateItemQuantity(item.id, item.quantity - 1)}
                          className="p-1 bg-gray-200 rounded hover:bg-gray-300"
                        >
                          <Minus className="w-4 h-4" />
                        </button>
                        <span className="w-6 sm:w-8 text-center text-sm">{item.quantity}</span>
                        <button
                          onClick={() => updateItemQuantity(item.id, item.quantity + 1)}
                          className="p-1 bg-gray-200 rounded hover:bg-gray-300"
                        >
                          <Plus className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => removeItem(item.id)}
                          className="p-1 bg-red-200 rounded hover:bg-red-300 text-red-700"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Sent Items */}
          {sentItems.length > 0 && (
            <div className="mb-4">
              <h4 className="font-medium text-gray-700 mb-2">Mutfaƒüa G√∂nderildi</h4>
              <div className="space-y-2">
                {sentItems.map((item) => (
                  <div
                    key={item.id}
                    className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2 p-2 bg-blue-50 rounded"
                  >
                    <div className="flex-1 w-full">
                      <div className="font-medium">{item.products.name}</div>
                      <div className="text-sm text-gray-600">
                        {item.price.toFixed(2)} ‚Ç∫ x {item.quantity} ={' '}
                        {(item.price * item.quantity).toFixed(2)} ‚Ç∫
                      </div>
                      {item.note && (
                        <div className="text-xs text-indigo-600 mt-1 italic">
                          üìù {item.note}
                        </div>
                      )}
                    </div>
                    {canEdit && (
                      <div className="flex items-center gap-2">
                        <button
                          onClick={() => removeItem(item.id)}
                          className="p-1 bg-red-200 rounded hover:bg-red-300 text-red-700"
                          title="√úr√ºn√º Sil"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Total */}
          <div className="border-t pt-4 mt-4">
            <div className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3">
              <div className="flex justify-between items-center text-xl font-bold">
                <span>Toplam:</span>
                <span className="ml-4">{order.total_price.toFixed(2)} ‚Ç∫</span>
              </div>
            </div>
          </div>
        </div>
      )}

      {!order && (
        <div className="bg-white rounded-lg shadow p-8 text-center">
          <p className="text-gray-600 mb-4">Bu masa i√ßin aktif sipari≈ü yok.</p>
          <button
            onClick={createOrder}
            className="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700"
          >
            Yeni Sipari≈ü Olu≈ütur
          </button>
        </div>
      )}

    </div>
  )
}
